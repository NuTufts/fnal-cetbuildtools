#!/bin/bash
########################################################################
# buildtool
#
# General purpose CMake / build script for packages using cetbuildtools.
#
# Chris Green <greenc@fnal.gov>
#
# 2011/11/10
########################################################################

function real_dir() {
    [[ -n "$1" ]] || return 1
    ( cd "$1" >/dev/null 2>&1 && /bin/pwd 2>/dev/null; exit $? )
    return $?
}

# Basic safety checks.
if [[ -z "$CETPKG_BUILD" ]] || [[ -z "$CETPKG_SOURCE" ]] || [[ -z "$CETPKG_TYPE" ]]; then
  echo "ERROR: Expected CETPKG_BUILD and friends to be set: source setup_for_development?" 1>&2
  exit 1
elif [[ ! -d "$CETPKG_BUILD" ]] || [[ ! -w "$CETPKG_BUILD" ]]; then
  echo "ERROR: CETPKG_BUILD \"$CETPKG_BUILD\" does not exist,
is not a directory or is not writable." 1>&2
  exit 1
elif [[ $(real_dir "$CETPKG_BUILD") == $(real_dir "$CETPKG_SOURCE") ]]; then
  echo "ERROR: CETPKG_BUILD ($CETPKG_BUILD) is identical to
CETPKG_SOURCE (${CETPKG_SOURCE})." 1>&2
  exit 1
elif [[ $(real_dir "$CETPKG_BUILD") == $(real_dir "$CETPKG_SOURCE")/* ]]; then
  echo "ERROR: CETPKG_BUILD ($CETPKG_BUILD) is a subdir of
CETPKG_SOURCE (${CETPKG_SOURCE})." 1>&2
  exit 1
elif [[ $(real_dir "$CETPKG_SOURCE") == $(real_dir "$CETPKG_BUILD")/* ]]; then
  echo "ERROR: CETPKG_SOURCE ($CETPKG_SOURCE) is a subdir of
CETPKG_BUILD (${CETPKG_BUILD})." 1>&2
  exit 1
elif [[ "$CETPKG_BUILD" == "/" ]]; then
  echo "ERROR: CETPKG_BUILD == /" 1>&2
  exit 1
elif [[ "$CETPKG_BUILD" != /* ]]; then
  echo "ERROR: CETPKG_BUILD appears to be relative." 1>&2
  exit 1
elif [[ $(real_dir "$CETPKG_BUILD") == "${HOME}" ]] || \
     [[ $(real_dir "$CETPKG_BUILD") == ~ ]]; then
  echo "ERROR: CETPKG_BUILD has been set to your home directory." 1>&2
  exit 1
fi

# Program name.
prog=${0##*/}

# Usage.
function usage() {
  local exitval
  local long
  if [[ "$1" == "long" ]]; then
    (( long = 1 ))
    shift
  fi
  (( exitval = ${1:-1} ))
  cat 1>&2 <<EOF
usage: ${prog} [<mode-options>] [<misc-options>] [--] [<make-build-options>]
       ${prog} --help|-h

Mode options: [-C|--cmake-only|-A|--all|--info] ||
              { [-b|--build] [-i|--install] [-p|--package] [-t|--test] [-T|--test-all] }

Misc options: [-D<CMake-definition>]+ [-I|--install-prefix <install-location>]
              [-c|--clean] [-f|--force-top] [-j #]
              [-l|--log=|--log-file=[<log-file>]] [-q|--quiet] [--tee]
              [--test-groups|--groups <group>[<;|,><group>]+]

Options suffixed  with '+' are repeatable and cumulative.

Required environment: CETPKG_BUILD, CETPKG_SOURCE, CETPKG_TYPE
Optional environment: CETPKG_INSTALL CETPKG_J CETPKG_QUAL
EOF
  (( ${long:-0} )) && cat 1>&2 <<EOF


DETAILS.

The following environment variables *must* be set:

CETPKG_BUILD:   The build area for the current package.
CETPKG_SOURCE:  The source area for the current package (containing the
                top-level CMakeLists.txt).
CETPKG_TYPE:    The build type, required by CMake.

Optional environment variables:

CETPKG_INSTALL: The default location of the private (or public) UPS
                products area into which to install the package if
                install is requested. This is overridden by -I option,
                but will override existing CMAKE_INSTALL_PREFIX from
                CMake.
CETPKG_J:       Default parallelism for all appropriate steps, assuming
                -j is not specified explicitly.

CETPKG_QUAL:    If set, causes -Dqualifier:STRING=$CETPKG_QUAL to be
                added to the CMake arguments.

MODE OPTIONS.

If -A (--all) or -C (--cmake-only) are set, they override all other mode
options. The cmake-only option overrides the all option. If any of the
other options are selected, they will be executed in order *after* the
CMake stage (which is always executed in the CETPKG_BUILD directory).

-A|--all

  Execute all targets.

-C|--cmake-only

  Execute *only* the CMake stage.

-T|--test-all

  Equivalent to -t --test-groups=all.

-b|--build

  Execute the build stage from the current directory. Since this is
  default, this is only required if you specify --install or --package
  and do *not* also specify test (see below).

-i|--install

  Execute the install stage from CETPKG_BUILD. CMake's generated build
  procedure will ensure that all build targets are up to date so the
  explicit build option is deactivated. However, you *may* wish to
  specify --build anyway in the case that you wish to pass arguments to
  the make procedure for the build phase.

--info

  If already configured (CMake has been run at least once), give some
  basic information about the package, then exit.

-p|--package

  Execute the package stage from CETPKG_BUILD to create an install
  tarball. See the notes for --install above regarding the build option.

--short-circuit|--sc

  Execute only the specified targets and not those that might be implied
  (CMake stage, build stage when test stage is specified, etc).

-t|--test

  Execute configured tests with ctest from the current
  directory. Implies --build.


MISC. OPTIONS.

-D<CMake-definition>

  Pass definitions to the invocation of the CMake stage. A warning shall
  be issued if this option is specified but the CMake stage is not to be
  executed.

-I|--install-prefix <ups-install-dir>

  Specify the location of the private (or public) UPS products area into
  which to install the package if install is requested. Overrides
  the CETPKG_INSTALL environment variable and anything already known to
  CMake.

-c|--clean

  Remove *everything* in the CETPKG_BUILD area, including CMake cache
  files. If you want the equivalent of make clean, you should invoke:

    buildtool -- clean

  from CETPKG_BUILD.

--force-top

  Force build and test stages (if applicable) to take place in the
  CETPKG_BUILD area (default is to build / test in current directory).

-h|--help

  This help (long-form).

-j #

  Specify the level of parallelism for stages for which it is
  appropriate.

-l|--log=|--log-file=[<log-file>]

  All build output is redirected to the specified log-file, or one with
  a default name if no other is specified. Unless --quiet is also
  specified, stage information will still be printed to the screen,
  though see --tee below. Note that the argument to the short variant,
  if used, must *immediately* follow the "-l" with no space. The long
  forms may optionally use "=" (but spaces are also not permitted here).

-q|--quiet

  Suppress all non-error output to the screen (but see --tee below). A
  log file will still be written as normal if so specified.

--tee

  Write to a log file (either as specified by --log or the default), but
  copy output to the screen also: --quiet is overridden by this option.

--test-groups|--groups <group>[<;|,><group>]+

  Specify optional test groups to configure per cet_test macro
  (CetTest.cmake). Equivalent to -DET_TEST_GROUPS=... if multiple groups
  are delimited with semicolons they should be escaped or quoted.to
  protect them from the shell. A warning shall be issued if this option
  is specified but the CMake stage is not to be executed.

EXAMPLES.

Build, test, install and create a package tarball from scratch with
output to a default-named log file, using parallelism:

  $prog -A -c -l -I <install-dir> -j16

As above, but copying output to screen:

  $prog -A -c -l --tee -I <install-dir> -j16

The need for the -I option may be obviated by defining CETPKG_INSTALL;
the need for the explicit parallelism may be similarly voided by
defining (eg) CETPKG_J=16.

To build a particular target only (eg):

  cd art/Framework/IO/Root; buildtool -- RootOutput_source.o

To build and test only:

  buildtool -t -j16

To install and package only:

  buildtool -i -p -j16
EOF

  exit ${exitval}
}

# Obtain a given CMake variable.
function cmake_var() {
  ( cd "$CETPKG_BUILD" && cmake -N -L | grep -e '^'"$1"':' | cut -d= -f2- ) 2>/dev/null
}

function package_name() {
    echo "$(cmake_var product)"
}

function package_version() {
  echo "$(cmake_var VERSION_MAJOR).$(cmake_var VERSION_MINOR).$(cmake_var VERSION_PATCH)"
}

function package_info() {
  local package_name=$(package_name)
  local package_version=$(package_version)
  [[ -n "$package_name" ]] && [[ -n "$package_version" ]] || return
  local msg="INFO: $package_name version $package_version configured."
  banner "$msg"
  log_no_tee && report "$msg" 1>&3
}

# Banner line
function banner() {
  (( ${quiet:-0} )) && return
  if [[ -n "$2" ]]; then
    local redir="1>&$1"
    shift
  fi
  eval cat $redir <<EOF

------------------------------------
$1
------------------------------------

EOF
}

function log_no_tee() {
  [[ -n "$log" ]] && (( ! ${tee:-0} ))
  return $?
}

function report() {
  (( ${report:-0} )) && echo "$*"
}

function error() {
  local errmsg="$*"
  printf "$errmsg\n\n" 1>&2
  log_no_tee && echo "$errmsg" 1>&4
}

# Check status and exit if necessary
function check_status() {
  local status=$?
  if [[ -n "$1" ]]; then # Override
    status=$1
  fi
  if (( status == 0 )); then
    banner "INFO: Stage $stage successful."
    log_no_tee && \
        report "INFO: Stage $stage successful." 1>&3
  else
    banner 2 "ERROR: Stage $stage failed."
    log_no_tee && \
        echo "ERROR: Stage $stage failed with code $status: see $log for details." 1>&4
    exit $status
  fi
  return $status
}

# Announce the next stage.
function announce_stage() {
  banner "INFO: Stage $stage${@}."
  if log_no_tee; then
    report "INFO: Stage $stage${@}." 1>&3
  fi
}

function check_curdir_in_build_tree() {
  if [[ $(real_dir .) != $(real_dir "$CETPKG_BUILD")* ]]; then
    error "INFO: current directory $(real_dir .) is not in the current build tree
         ($(real_dir "$CETPKG_BUILD")). Executing stage $stage from \$CETPKG_BUILD."
    cd "$(real_dir "$CETPKG_BUILD")"
  fi
}

function maybe_force_top_and_announce() {
  if [[ $(real_dir .) == $(real_dir "$CETPKG_BUILD")/* ]]; then
    if (( ${force_top:-0} )); then
      cd "$(real_dir "$CETPKG_BUILD")"
      announce_stage " in $(real_dir .) per --force-top"
    else
      announce_stage " in $(real_dir .) (--force-top to override)"
    fi
  else
    announce_stage
  fi
}

# Clean up
function restore_output_streams() {
  if log_no_tee; then
    exec 2>&4- 1>&3-
  fi
}

function cleanup() {
  [[ -n "$TMP" ]] && [[ -d "$TMP" ]] && rm -rf "$TMP"
}

# Main work
function do_work() {
  if log_no_tee; then
    exec 3>&1 4>&2 >"$log" 2>&1
    trap "restore_output_streams; cleanup" EXIT
  fi
  stage=cmake
  if (( ${short_circuit:-0} && ! ${cmake_only:-0} )); then
    announce_stage " SKIPPED per --short-circuit"
    if [[ -n "${cmake_defs}" ]]; then
      error "WARNING: CMake definitions ignored since CMake not invoked."
    fi
  else
    announce_stage
    local extradef
    [[ -n "$CETPKG_QUAL" ]] && extradef="-Dqualifier:STRING=$CETPKG_QUAL "
    cmake_defs=${cmake_defs//,/;}
    ( cd "$CETPKG_BUILD" && cmake -DCMAKE_INSTALL_PREFIX="$install_prefix" -DCMAKE_BUILD_TYPE=$CETPKG_TYPE ${extradef}${cmake_defs}${CETPKG_SOURCE} )
    check_status
    package_info
    (( ${cmake_only:-0} )) && exit 0
  fi

  if (( ${do_build:-0} == 1 || ( ${do_build:-0} > 1 && ! ${short_circuit:-0} ) )); then
    stage=build
    maybe_force_top_and_announce
    check_curdir_in_build_tree
    time make $jarg "$@"
    check_status
  fi

  if (( ${do_test:-0} )); then
    stage=test
    maybe_force_top_and_announce
    check_curdir_in_build_tree
    # Trap and tee *only* stderr from ctest. Yes, this is fiddly.
    TMP=`mktemp -d -t buildtool.XXXXXXXXXX`
    if [[ -z "$TMP" ]]; then
      error "ERROR: Unable to create temporary working directory: aborting buildtool execution."
      exit 1
    fi
    exec 5>&1
    { ctest $jarg 2>&1 >&5 5>&-; echo $? > "$TMP/status.dat"; } | tee "$TMP/ctest.err" 5>&-
    exec 5>&-
    local status
    (( status = $(cat "$TMP/status.dat") ))
    if (( status == 0 )) && [[ -s "$TMP/ctest.err" ]]; then
      error "ERROR: Detected stderr output from ctest."
      check_status 1
    else
      check_status $status
    fi
  fi

  if [[ -n "$targets" ]]; then
    stage="install / package"
    announce_stage
    ( cd "$CETPKG_BUILD" && make $jarg $targets )
    check_status
  fi
}

# Defaults.
log_default="build_`date \"+%Y-%m-%d\"`.log"
(( report = 1 ))

# Parse arguments.
TEMP=`getopt -n "$prog" --long all,cmake-only,install-prefix:,build,clean,force-top,groups:,help,info,install,log::,log-file::,package,quiet,sc,short-circuit,tee,test,test-all,test-groups: -o +ACD:I:Tbcfhij:l::pqt -- "${@}"`
if (( $? )); then
  usage 1
fi

if [[ -n "$CETPKG_J" ]]; then
  jarg="-j$CETPKG_J"
fi

eval set -- "$TEMP"
while true; do
  case $1 in
    -A|--all)
      (( all = 1 ))
      shift
      ;;
    -C|--cmake-only)
      (( cmake_only = 1 ))
      shift
      ;;
    -D)
      cmake_defs="${cmake_defs}${1}${2} "
      shift
      shift
      ;;
    -I|--install-prefix)
      install_prefix=$2
      shift
      shift
      ;;
    -T|--test-all)
      shift
      set -- -t --test-groups all "${@}"
      ;;
    -b|--build)
      (( do_build = 1 ))
      shift
      ;;
    -c|--clean)
      (( clean = 1 ))
      shift
      ;;
    -f|--force-top)
      (( force_top = 1 ))
      shift
      ;;
    -h|--help)
      usage long
      shift
      ;;
    -i|--install)
      (( no_build = 1 ))
      targets="$targets install"
      shift
      ;;
    --info)
      (( want_info = 1 ))
      shift
      ;;
    -j)
      jarg="-j$2"
      shift
      shift
      ;;
    -l|--log|--log-file)
      if [[ -d "$2" ]]; then
        log="$2/${log_default}"
      else
        log="${2:-${log:-${log_default}}}"
      fi
      shift
      shift
      ;;
    -p|--package)
      (( no_build = 1 ))
      targets="$targets package"
      shift
      ;;
    -q|--quiet)
      (( quiet = 1 ))
      shift
      ;;
     --short-circuit|--sc)
      (( short_circuit = 1 ))
      shift
      ;;
    -t|--test)
      (( do_build = 2 )) # May be overridden by ${short_circuit}.
      (( do_test = 1 ))
      shift
      ;;
    --tee)
      log="${log:-${log_default}}"
      (( tee = 1 ))
      shift
      ;;
    --test-groups|--groups)
      if [[ -n "$test_groups" ]]; then
        test_groups="${test_groups};${2}"
      else
        test_groups="${2}"
      fi
      shift
      shift
      ;;
    --)
      shift
      break
      ;;
    *)
      echo "Bad argument $1" 1>&2
      usage 1
  esac
done

# If desired, print current build information and quit.
if (( ${want_info:-0} )); then
  if [[ -n $(package_name) ]]; then
    cat <<EOF
Package info: $(package_name) $(package_version)
Build type:   $(cmake_var CMAKE_BUILD_TYPE)
Qualifier:    $(cmake_var qualifier)
EOF
    exit 0
  else
    echo "ERROR: CMake not run; no current information in build area." 1>&2
    exit 1
  fi
fi

# Make sure output will appear as we'd like.
if (( ${tee:-0} )); then
  # You asked for stuff to the screen -- that's what you'll get.
  unset quiet
  unset report
elif (( ${quiet:-0} )); then
  # If we're not teeing a logfile, you don't want screen reports.
  unset report
fi

# If you're logging to file (but not using tee) we don't want quiet (but
# reports may be turned off).
if log_no_tee; then
  unset quiet
fi

# Did we specify all?
if (( ${all:-0} )); then
  (( do_build = 1 ))
  (( do_test = 1 ))
  targets="install package"
else
  # In general, build unless we've been asked not to where that is
  # compatible with our other options.
  (( do_build = ${do_build:-0} | ! ${no_build:-0} ))
fi

if (( ${clean:-0} )); then
  if [[ $(real_dir .) == $(real_dir "$CETPKG_BUILD")/* ]]; then
    echo "ERROR: Clean operation would remove the current directory!" 1>&2
    exit 2
  fi
  if (( $(ls -1 "${CETPKG_BUILD}" | wc -l) )) && ! [[ -f "${CETPKG_BUILD}/cetpkg_variable_report" ]]; then
    echo "ERROR: Refusing to clean suspect non-empty build directory \"${CETPKG_BUILD}\"" 1>&2
    echo "       Double-check value and contents of \$CETPKG_BUILD." 1>&2
    exit 2
  fi
  trap "f=$?; printf \"\nAborted\n\" 1>&2; cleanup; exit $f" 2
  printf "INFO: About to clean \"$CETPKG_BUILD\": ctrl-C to abort within 5 seconds "
  for i in 1 2 3 4 5; do printf "."; sleep 1; done
  printf "\n";
  pushd /tmp >/dev/null # 2>&1
  report "INFO: Cleaning \"$CETPKG_BUILD\" ..."
  if ! { find "$CETPKG_BUILD" -mindepth 1 -maxdepth 1 | \
         grep -v -e '/diag_report$' -e '/cetpkg_variable_report$' | \
         xargs rm -rf; }; then
    echo "ERROR: Unable to clean directory \"$CETPKG_BUILD\"" 1>&2
    exit 2
  fi
  popd >/dev/null || cd "$CETPKG_BUILD" # 2>&1
  trap 2
else # Check consistency.
  # product_deps is read and acted upon during source of
  # setup_for_development. If it's changed since then, we have a
  # problem.
  if [[ "$CETPKG_SOURCE/ups/product_deps" -nt "$CETPKG_BUILD/cetpkg_variable_report" ]]; then
    printf "ERROR: product_deps has changed since the last time setup_for_development\n"
    printf "       was sourced: re-source before building.\n" 1>&2
    exit 2
  fi
  check_build_type="$(cmake_var CMAKE_BUILD_TYPE)"
  if [[ -n "$check_build_type" ]] && [[ "$check_build_type" != "$CETPKG_TYPE" ]]; then
    echo "ERROR: Build type has changed from $check_build_type to $CETPKG_TYPE: need clean build." 1>&2
    exit 2
  fi
  check_qual="$(cmake_var full_qualifier)"
  if [[ -n "$check_qual" ]] && [[ "$check_qual" != "$CETPKG_QUAL" ]]; then
    echo "ERROR: Qualifier has changed from \"$check_qual\" to \"$CETPKG_QUAL\": need clean build." 1>&2
    exit 2
  fi
fi

cmake_defs="${cmake_defs}-DCET_TEST_GROUPS=${test_groups} "

# Set install prefix from wherever we can get it.
install_prefix=${install_prefix:-${CETPKG_INSTALL}}
install_prefix=${install_prefix:-$(cmake_var CMAKE_INSTALL_PREFIX)}

# Check we found an install prefix.
if [[ -z "$install_prefix" ]]; then
  echo "ERROR: Install prefix not specified, CETPKG_INSTALL not set and CMAKE_INSTALL_PREFIX cannot be obtained from CMake cache." 1>&2
  usage 2
fi

report "INFO: CETPKG_TYPE = $CETPKG_TYPE"

if [[ "$targets" == *install* ]] && \
   { [[ ! -d "$install_prefix" ]] || [[ ! -w "$install_prefix" ]]; }; then
  echo "ERROR: Install prefix does not exist as a directory or is not writable with install target selected." 1>&2
fi

# Want absolute dir
install_prefix="`( cd \"$install_prefix\" >/dev/null 2>&1 && /bin/pwd)`"

# Suppress messages if desired.
if (( ${quiet:-0} )); then
  exec >/dev/null
fi

if [[ -n "$@" ]]; then
  report "Extra arguments to make for build stage: $@"
fi

# If we're tee-ing.
if (( ${tee:-0} )); then
  do_work "$@" 2>&1 | tee "$log"
else
  do_work "$@"
fi

# Done.
